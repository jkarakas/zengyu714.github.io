---
author: kimmy
layout: post
title:  "Encoding and decoding"
date:   2017-02-09 01:01:19 +08:00
categories: Python
tags:
- Python
- Notes
- Trivia
- Codec
---

* content
{:toc}



## `str` in Python3 == `unicode` in Python2

```python
string = 'café'
len(string)
```




    4



Encode `str` to `bytes` using UTF-8 encoding  
`bytes` literals start with a `b` prefix


```python
byte = string.encode('utf8')
b
```




    b'caf\xc3\xa9'



`bytes b` has five bytes (the code point for “é” is encoded as two bytes in UTF-8).  
The first three bytes `b'caf'` are in the printable ASCII range, the last two are not.


```python
len(byte)
```




    5



Decode `bytes` to `str` using UTF-8 encoding


```python
byte.decode('utf8')
```




    'café'



## Basic Encoders/Decoders

There are more than 100 codecs (encoder/decoder) for text to byte conversion and vice versa.  
Codec can be used as the `encoding` argument in
functions like `open()`, `str.encode()`, `bytes.decode()` and so on.

### Example
The string “你好” encoded with three codecs producing very different byte sequences


```python
for codec in ['gbk','gb2312','utf-8','utf-16']:
    print(codec, '你好'.encode(codec),sep = '\t')
```

    gbk	b'\xc4\xe3\xba\xc3'
    gb2312	b'\xc4\xe3\xba\xc3'
    utf-8	b'\xe4\xbd\xa0\xe5\xa5\xbd'
    utf-16	b'\xff\xfe`O}Y'


Chinese characters use less space in GBK and GB-2312, mostly.
### About ascii, unicode and utf-8
see [more](https://www.zhihu.com/question/23374078 "details")  

## Encode/Decode Problems

### UnicodeEncodeError


```python
hello = '你好'
hello.encode('utf-8')
```




    b'\xe4\xbd\xa0\xe5\xa5\xbd'




```python
hello.encode('gb2312')
```




    b'\xc4\xe3\xba\xc3'




```python
hello.encode('cp437')
```


    ---------------------------------------------------------------------------

    UnicodeEncodeError                        Traceback (most recent call last)

    <ipython-input-37-c66353262ceb> in <module>()
    ----> 1 hello.encode('cp437')


    C:\ProgramData\Anaconda2\envs\py3\lib\encodings\cp437.py in encode(self, input, errors)
         10
         11     def encode(self,input,errors='strict'):
    ---> 12         return codecs.charmap_encode(input,errors,encoding_map)
         13
         14     def decode(self,input,errors='strict'):


    UnicodeEncodeError: 'charmap' codec can't encode characters in position 0-1: character maps to <undefined>



```python
hello.encode('cp437', errors = 'replace')
# errors = ignore
```




    b'??'



### UnicodeDecodeError


```python
gb2312_byte = b'\xc4\xe3\xba\xc3'
gb2312_byte.decode('gb2312')
```




    '你好'




```python
gb2312_byte.decode('cp1252')
```




    'ÄãºÃ'




```python
gb2312_byte.decode('koi8_r')
```




    'дЦ╨ц'




```python
gb2312_byte.decode('utf-8')
```


    ---------------------------------------------------------------------------

    UnicodeDecodeError                        Traceback (most recent call last)

    <ipython-input-43-7d80761aa05d> in <module>()
    ----> 1 gb2312_byte.decode('utf-8')


    UnicodeDecodeError: 'utf-8' codec can't decode byte 0xc4 in position 0: invalid continuation byte


### KEYNOTE
---
1. Declare `# -*- coding: utf-8 -*-`  if use non-ascii characters.
2. Chardet — The Universal Character Encoding Detector works to identify one of 30 supported encodings.  
   Here's an example from [real life](https://github.com/conda/conda/issues/4567])

    ```
    import chardet

    def ensure_text_type(value):
        if isinstance(value, text_type):
            encoding = 'utf-8'
        else:
            encoding = chardet.detect(value).get('encoding') or 'utf-8'
        return value.decode(encoding) if hasattr(value, 'decode') else value
    ```

3. INPUT == >> decode bytes == >> TEXT == >> decode text == >> OUTPUT  
    `my_file.read()` and `my_file.write()` are `str` objects

## Excoding setting

is returned by `locale.getpreferredencoding()`: it is the default for opening text files and for `sys.stdout/stdin/stderr` when they are redirected to files


```python
open('test.txt','w',encoding = 'utf-8').write('café')
```




    4



Code that has to run on multiple machines or on multiple occasions should **never** depend on **encoding defaults**.


```python
open('test.txt').read()
```




    'caf茅'




```python
open('test.txt',encoding = 'utf-8').read()
```




    'café'



## Binary sequences

1. the immutable `bytes` type introduced in Python 3
2. the mutable `bytearray`, added in Python 2.6.

### Example:

`bytes` can be built from a `str`, given an encoding


```python
cafe = bytes('café', encoding='utf_8')
cafe
```




    b'caf\xc3\xa9'



Index of `bytes` is an integer in `range(256)`  
Slices of `bytes` are also `bytes`—even slices of a single byte


```python
print(cafe[0])
print (cafe[:1])
```

    99
    b'c'


Construct `bytearray()` with a `bytes` literal as argument


```python
cafe_arr = bytearray(cafe)
cafe_arr
```




    bytearray(b'caf\xc3\xa9')



A **slice** of `bytearray` is also a `bytearray`.


```python
cafe_arr[-1:]
```




    bytearray(b'\xa9')



### KEYNOTE
---
1. The only sequence type where `s[0] == s[:1]` is the `str` type.
2. For every other sequence, `s[i]` returns **one item**, and `s[i:i+1]` returns **a sequence of the same type** with the `s[i]` item inside it.

### Structs and Memory Views

`struct` converses **tuples** <==> **packed bytes**  
`memoryview class` provides *shared memory access* to slices of data from
other binary sequences, packed arrays, and buffers such as Python Imaging Library
(PIL) images, *without copying the bytes*.

#### ATTENTION
---
**Delete** references to release the memory associated with the `memoryview` instances
